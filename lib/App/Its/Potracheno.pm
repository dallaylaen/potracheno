package App::Its::Potracheno;

use strict;
use warnings;

our $VERSION = 0.1109;

=head1 NAME

App::Its::Potracheno - a technical debt assessment tool.

=head1 DESCRIPTION

Potracheno is a technical debt tracker similar to a normal gubtracker.
However, instead of tracking time spent on resolving an issue,
it tracks time wasted by the team because of it.

=head1 SYNOPSIS

    plackup -MApp::Its::Potracheno -e 'run("/my/config");'

    perl -MApp::Its::Potracheno -e 'print get_schema_sqlite();'

Here C</my/config> is a L<App::Its::Potracheno::Config> config file,
but migration to C<Config::Gitlike> planned.

=head1 FUNCTIONS

All functions are exported by default for brevity.

=cut

use Carp;
use URI::Escape;
use Data::Dumper;
use POSIX qw(strftime);
use Digest::MD5 qw(md5_base64);
use Encode;
use File::Basename qw(dirname);
use File::ShareDir qw(module_dir);

use parent 'Exporter';
our @EXPORT = qw(run get_schema_mysql get_schema_sqlite);

use MVC::Neaf 0.17;
use MVC::Neaf qw(:sugar neaf_err);
use MVC::Neaf::X::Form;
use MVC::Neaf::X::Form::Data;
use App::Its::Potracheno::Model;
use App::Its::Potracheno::Config; # TODO replace ->config::gitlike
use App::Its::Potracheno::Update;

=head2 run( \%config || $config_file )

Parse config, initialize model (L<App::Its:Potracheno::Model & friends),
return a PSGI app subroutine.

=cut

our $CONFIG;
sub run {
    croak "Usage: ".__PACKAGE__."::run( 'config_file' );"
        unless @_ == 1;

    local $CONFIG = shift;
    my $app = do 'App/Its/Potracheno/Routes.pm';

    croak "Failed to load App/Its/Potracheno/Routes.pm: "
        .($@ || $! || "unknown reason")
            unless ref $app eq 'CODE';

    # return $app;
    neaf->run;
}; # sub run ends here

=head2 get_schema_sqlite()

=head2 get_schema_mysql()

Use these functions to fetch database schema:

    perl -MApp::Its::Potracheno -we 'print get_schema_sqlite()' | sqlite3 base.sqlite

=cut

sub get_schema_sqlite {
    return <<'SQL';
CREATE TABLE user (
    user_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name varchar(20) UNIQUE,
    password varchar(256),
    admin INT(1) DEFAULT 0,
    banned INT(1) DEFAULT 0,
    created INT -- unix time
);

CREATE TABLE issue (
    issue_id INTEGER PRIMARY KEY AUTOINCREMENT,
    summary varchar (256) NOT NULL,
    body varchar(4096) NOT NULL,
    user_id INT,
    status_id INT default 1, -- doesn't address any table, statuses are conf'ed
    created INT -- unix time
);

CREATE TABLE activity (
    activity_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INT NOT NULL,
    issue_id INT NOT NULL,
    seconds INT,
    fix_estimate INT,
    note varchar(4096),
    created INT -- unix time
);

CREATE TABLE sess (
    sess_id varchar(43) PRIMARY KEY,
    user_id INTEGER NOT NULL,
    created INT -- unix time
);

CREATE TABLE reset_request (
    reset_request_id INTEGER PRIMARY KEY AUTOINCREMENT,
    reset_key varchar(80) UNIQUE NOT NULL,
    user_id INT NOT NULL,
    expires INT NOT NULL, --unix time
    created INT -- unix time
);

CREATE TABLE watch (
    watch_id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INT NOT NULL,
    issue_id INT NOT NULL,
    created INT -- unix time
);

CREATE TABLE tag (
    tag_id INTEGER PRIMARY KEY AUTOINCREMENT,
    name varchar(20) NOT NULL,
    descr varchar(4096),
    created INT -- unix time
);

CREATE TABLE issue_tag (
    issue_tag_id INTEGER PRIMARY KEY AUTOINCREMENT,
    issue_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    created INT -- unix time
);

-- hand written indices
CREATE UNIQUE INDEX index__watch__user_id__issue_id ON watch (user_id,issue_id);
CREATE INDEX index__activity__seconds ON activity(seconds);
CREATE INDEX index__activity__fix_estimate ON activity(fix_estimate);
CREATE UNIQUE INDEX index__reset_request__reset_key ON reset_request(reset_key);
CREATE INDEX index__reset_request__user_id ON reset_request(user_id);

-- autogenerated indices (table + something_id)
CREATE INDEX index__issue__user_id ON issue (user_id);
CREATE INDEX index__issue__status_id ON issue (status_id);
CREATE INDEX index__activity__user_id ON activity (user_id);
CREATE INDEX index__activity__issue_id ON activity (issue_id);
CREATE INDEX index__sess__user_id ON sess (user_id);
CREATE INDEX index__watch__issue_id ON watch (issue_id);
CREATE INDEX index__issue_tag__issue_id ON issue_tag (issue_id);
CREATE INDEX index__issue_tag__tag_id ON issue_tag (tag_id);

-- autogenerated indices on time (only issue & activity)
CREATE INDEX index__issue__created ON issue (created);
CREATE INDEX index__activity__created ON activity (created);
CREATE INDEX index__reset_request__expires ON reset_request (expires);
SQL
};

sub get_schema_mysql {
    return <<'SQL';
DROP TABLE IF EXISTS user;
CREATE TABLE user (
    user_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    name varchar(20) UNIQUE,
    password varchar(256),
    admin INT(1) DEFAULT 0,
    banned INT(1) DEFAULT 0,
    created INT -- unix time
) DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS issue;
CREATE TABLE issue (
    issue_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    summary varchar (256) NOT NULL,
    body varchar(4096) NOT NULL,
    user_id INT,
    status_id INT default 1,
    created INT -- unix time
) DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS activity;
CREATE TABLE activity (
    activity_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    issue_id INT NOT NULL,
    seconds INT,
    fix_estimate INT,
    note varchar(4096),
    created INT -- unix time
) DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS sess;
CREATE TABLE sess (
    sess_id varchar(43) PRIMARY KEY,
    user_id INTEGER NOT NULL,
    created INT -- unix time
) DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS reset_request;
CREATE TABLE reset_request (
    reset_request_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    reset_key varchar(80) UNIQUE NOT NULL,
    user_id INTEGER NOT NULL,
    expires INT NOT NULL, -- unix time
    created INT -- unix time
) DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS watch;
CREATE TABLE watch (
    watch_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    user_id INTEGER NOT NULL,
    issue_id INTEGER NOT NULL,
    created INT -- unix time
);

DROP TABLE IF EXISTS tag;
CREATE TABLE tag (
    tag_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    name varchar(20) NOT NULL,
    descr varchar(4096),
    created INT -- unix time
);

DROP TABLE IF EXISTS issue_tag;
CREATE TABLE issue_tag (
    issue_tag_id INTEGER PRIMARY KEY AUTO_INCREMENT,
    issue_id INTEGER NOT NULL,
    tag_id INTEGER NOT NULL,
    created INT -- unix time
);
SQL
};


1;
